<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hex — Common Multiple Placement (Simplified)</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
/* CSS Variables for elegant UI */
:root{
  --bg-1:#fefefe; 
  --bg-2:#f0f4f9;
  --card:#ffffff; 
  --muted:#e2e8f0;
  --accent:#1f78c8; /* Deep Blue */
  --accent-2:#00509e;
  --red:#e34a4a; /* Deep Red */
  --red-dark:#c0392b;
  --win:#10b981;
  --max-width:1100px;
  --text-primary:#0f172a;
  --text-secondary:#64748b;
  --shadow-l: 0 10px 30px rgba(0,0,0,0.05);
  --shadow-m: 0 4px 12px rgba(0,0,0,0.08);
  --shadow-s: 0 1px 3px rgba(0,0,0,0.05);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue";background:var(--bg-2);color:var(--text-primary)}
.wrap{max-width:var(--max-width);margin:16px auto;padding:16px}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:20px}
.title{display:flex;flex-direction:column}
.title h1{margin:0;font-size:24px;font-weight:800}
.title p{margin:0;font-size:14px;color:var(--text-secondary)}
.controls{display:flex;gap:12px;align-items:center}
.btn{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:white;padding:10px 16px;border-radius:12px;border:none;font-weight:700;cursor:pointer;transition:transform 0.1s, box-shadow 0.1s; box-shadow: var(--shadow-m);}
.btn:hover{transform:translateY(-1px);box-shadow: 0 6px 16px rgba(0,0,0,0.15)}
.ghost{background:transparent;border:1px solid var(--muted);color:var(--text-primary);padding:10px 16px;border-radius:12px;font-weight:600;cursor:pointer;transition:background 0.1s}
.ghost:hover{background:var(--muted)}

.layout{display:grid;grid-template-columns:1fr 340px;gap:20px}
@media (max-width:980px){ .layout{grid-template-columns:1fr} .sidebar{order:2;margin-top:20px} .board-panel{order:1} }
.panel{background:var(--card);padding:20px;border-radius:16px;border:1px solid var(--muted);box-shadow:var(--shadow-l)}
.status{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:15px;border-bottom:1px solid var(--muted)}
.dice{display:flex;gap:12px;align-items:center}
.die{width:64px;height:64px;border-radius:14px;background:#fff;color:var(--text-primary);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:24px;box-shadow:var(--shadow-m);border:3px solid var(--muted);animation:diceRoll 0.1s infinite alternate;}
.die.ready{animation:none;}
@keyframes diceRoll {from {transform: rotate(0deg);} to {transform: rotate(2deg);}}
.turn-indicator{font-weight:800;font-size:16px;text-transform:uppercase;color:var(--accent)}

.board-scroll{overflow:auto;border-radius:12px;padding:10px;background:var(--bg-2);display:flex;justify-content:center;align-items:center; box-shadow: inset 0 2px 8px rgba(0,0,0,0.05);}
.grid-container{position:relative;display:inline-block;user-select:none;touch-action:manipulation; background-color: #eee; border-radius: 8px;}

/* Canvas specific sizing and styling */
#output {
    max-width: 100%;
    height: auto;
    display: block; 
}

.legend{display:flex;gap:15px;align-items:center;margin-top:15px;font-size:13px;color:var(--text-secondary)}
.small{font-size:13px;color:var(--text-secondary)}
.sidebar .section{margin-bottom:15px}
.select, .input {width:100%;padding:10px;border-radius:10px;background:var(--bg-2);border:1px solid var(--muted);color:var(--text-primary)}
.log{height:180px;overflow:auto;background:var(--bg-2);padding:10px;border-radius:10px;font-size:12px;color:var(--text-primary);border:1px solid var(--muted)}
.footer{margin-top:15px;font-size:13px;color:var(--text-secondary);padding-top:10px;border-top:1px solid var(--muted)}
@media (max-width:520px){ 
  .die{width:50px;height:50px;font-size:18px}
  .title h1{font-size:20px}
  .controls{flex-wrap: wrap;}
}
/* Modal Styles */
.modal-overlay {
  position: fixed; top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.7); display: none;
  align-items: center; justify-content: center; z-index: 10000;
  backdrop-filter: blur(4px);
  opacity: 0;
  transition: opacity 0.3s ease;
}
.modal-overlay.active {
  display: flex;
  opacity: 1;
}
.modal-content {
  background: var(--card); padding: 24px; border-radius: 16px;
  max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  transform: scale(0.95); transition: transform 0.3s ease;
  position: relative; 
}
.modal-overlay.active .modal-content {
  transform: scale(1);
}
.modal-content h2 { font-size: 20px; margin-top: 0; border-bottom: 1px solid var(--muted); padding-bottom: 10px; }
.modal-close-btn {
  position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-secondary); line-height: 1;
}
</style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <div class="title">
      <h1>NumberHex : A game to learn common multiples and strategy</h1>
      <p>Place on a your peice on any number that is a common multiple of the two dice rolls on the 11*11 Hex grid.</p>
    </div>

    <div class="controls">
      <select id="modeSelect" class="select" style="width:auto">
        <option value="single">Single Player (Bot)</option>
        <option value="multi">Multiplayer (Hotseat)</option>
      </select>
      <button id="howToPlayBtn" class="ghost">How to Play</button>
      <button id="newBtn" class="btn">New Game</button>
    </div>
  </div>

  <div class="layout">
    <!-- BOARD -->
    <section class="panel board-panel">
      <div class="status">
        <div>
          <div class="small">Current Turn: <span id="turnLabel" class="turn-indicator">Blue</span></div>
        </div>

        <div style="display:flex;align-items:center;gap:15px">
          <div class="dice">
            <!-- Removed fixed width/height attributes from canvas -->
            <div id="dieA" class="die ready">-</div>
            <div id="dieB" class="die ready">-</div>
          </div>
          <div style="display:flex;flex-direction:column;gap:8px;align-items:flex-end">
            <button id="passBtn" class="ghost">Pass Turn</button>
            <div class="small text-right">Made by Delhi Publi School, Harni</div>
          </div>
        </div>
      </div>

      <!-- CANVAS GRID AREA -->
      <div class="board-scroll">
        <div class="grid-container">
            <!-- Canvas now relies on JS for dimension sizing -->
            <canvas id="output">Canvas not supported...</canvas>
        </div>
      </div>
      <!-- END CANVAS GRID AREA -->

      <div class="legend">
        <div style="color:var(--accent); font-weight:700;">Blue Goal: Left to Right</div>
        <div style="color:var(--red); font-weight:700;">Red Goal: Top to Bottom</div>
      </div>
      <div class="footer">The game uses standard Hex 6-way connectivity.</div>
    </section>

    <!-- SIDEBAR -->
    <aside class="panel sidebar">
      <div class="section">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small"><strong>Game Info</strong></div>
          <div class="small" id="modeLabel">Mode: Single</div>
        </div>
        <div style="margin-top:8px" class="small">Grid: 11 times 11 (121 unique numbers). Dice are 1-10.</div>
      </div>

      <div class="section">
        <div class="small"><strong>Controls</strong></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="undoBtn" class="ghost">Undo Last Move</button>
        </div>
      </div>

      <div class="section">
        <div class="small"><strong>Log</strong></div>
        <pre id="log" class="log"></pre>
      </div>
    </aside>
  </div>
</div>

<!-- Instructions Modal -->
<div id="instructionsModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-content">
        <button class="modal-close-btn" onclick="hideInstructions()" aria-label="Close instructions">&times;</button>
        <h2 id="modalTitle">How to Play Hex — Common Multiple Placement</h2>
        <p>This is a two-player game (or one player against an AI bot) played on a $11 \times 11$ Hex board filled with numbers $1$ through $121$.</p>

        <h3>The Goal (Standard Hex Connection)</h3>
        <p>The Red and Blue borders indicate the goal lines:</p>
        <ul>
            <li>Blue Player (P1): Tries to create a continuous path of Blue pieces connecting the Left edge (Column 0) to the Right edge (Column 10).</li>
            <li>Red Player (P2): Tries to create a continuous path of Red pieces connecting the Top edge (Row 0) to the Bottom edge (Row 10).</li>
        </ul>

        <h3>Gameplay (Math Rule)</h3>
        <ol>
            <li>Blue goes first.</li>
            <li>At the start of each turn, two dice (numbered $1$ to $10$) are rolled.</li>
            <li>The player must place their piece on a tile whose value is a common multiple of both dice.</li>
            <li>The placement rule is: A tile can be placed only if <em>Tile Value / Die A</em> and <em>Tile Value / Die B</em> both result in a whole number (integer).</li>
            <li>**If no valid move exists: The player must click the Pass Turn button, and the turn is forfeited. The bot will pass automatically.</li>
            <li>The game ends immediately when one player successfully connects their sides.</li>
        </ol>
    </div>
</div>

<!-- Win Modal (Custom alert replacement) -->
<div id="modal-backdrop" class="modal-overlay" role="dialog" aria-modal="true">
    <div id="win-modal" class="modal-content text-center">
        <h2 id="modal-title" class="text-3xl font-extrabold mb-4 text-indigo-700">Game Over!</h2>
        <p id="modal-message" class="text-xl text-gray-600 mb-8 font-medium"></p>
        <button onclick="closeModal()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-8 rounded-xl shadow-lg transition duration-150 ease-in-out">
            OK / New Game
        </button>
    </div>
</div>


<script>
// --- Game Constants and State ---
const SIZE = 11; 
const TOTAL_CELLS = SIZE * SIZE;
const HEX_R = 35; // INCREASED: Hexagon radius for larger size
const HEX_W = HEX_R * Math.sqrt(3); // Hexagon width (flat-to-flat)

// Define minimal margins for the canvas rendering 
const X_MARGIN = HEX_R * 1.5; 
const Y_MARGIN = HEX_R * 1.5; 

const outputCanvas = document.getElementById('output');
const ctx = outputCanvas.getContext("2d");

const dieAEl = document.getElementById('dieA'), dieBEl = document.getElementById('dieB');
const turnLabel = document.getElementById('turnLabel');
const logEl = document.getElementById('log');
const modeSelect = document.getElementById('modeSelect'), modeLabel = document.getElementById('modeLabel');

let board = []; // Stores the owner ID (-1: empty, 1: Blue, 2: Red)
let boardValues = []; // Stores the numbers 1 to 121
let sel = [-1, -1]; // Currently hovered/selected hex [x, y]
let current = 1; // 1 Blue, 2 Red (owner IDs)
let dieA = null, dieB = null;
let moveHistory = [];
let mode = 'single';
let active = true; // Game active flag
let occupiedCount = 0; 

// --- Utility Functions ---
let audioCtx;
function tone(freq, t=0.08){ try{ if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sine'; o.frequency.value=freq; g.gain.value=0.06; o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + t);}catch(e){} }
function log(msg){ const time = new Date().toLocaleTimeString(); logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent; }
function isIntClose(x){ const eps = 1e-9; return Math.abs(Math.round(x) - x) < eps; }

/**
 * Calculates the center coordinates of a hex tile [x, y] on the canvas.
 * This function must match the logic used in draw() and getSel().
 */
function getCanvasCenter(x, y) {
    // Standard flat-top hex grid calculation with minimal offset
    const cx = x * HEX_W + y * (HEX_W / 2) + X_MARGIN;
    const cy = y * 1.5 * HEX_R + Y_MARGIN;
    return [cx, cy];
}

/**
 * Calculates the required canvas size dynamically and sets the element attributes.
 */
function calculateCanvasSize() {
    // Find the center of the bottom-rightmost tile (x=SIZE-1, y=SIZE-1)
    const [maxXCenter, maxYCenter] = getCanvasCenter(SIZE - 1, SIZE - 1);

    // Add HEX_R to the right (for the full width of the hex) and to the bottom (for the full height)
    // Add extra padding for aesthetic
    const padding = 20;

    outputCanvas.canvasWidth = Math.ceil(maxXCenter + HEX_R + padding);
    outputCanvas.canvasHeight = Math.ceil(maxYCenter + HEX_R + padding); 
    
    // Set the actual canvas element attributes
    outputCanvas.width = outputCanvas.canvasWidth;
    outputCanvas.height = outputCanvas.canvasHeight;
}


// --- Game Logic Functions ---

/**
 * Checks if an array b exists in array a (used for BFS visited sets).
 */
function findArr(a, b) {
    for (var i = 0; i < a.length; i++)
        if (a[i][0] == b[0] && a[i][1] == b[1])
            return i;
    return -1;
}

/**
 * Finds valid, unvisited neighbors for a given hex (x, y) owned by color c.
 * c is the owner ID (1 or 2).
 */
function getConnections(x, y, owner, open, closed) {
    // Hex neighbor offsets (x, y)
    // E, NE, NW, W, SW, SE
    var dx = [1, 0, -1, -1, 0, 1];
    var dy = [0, 1, 1, 0, -1, -1];
    var ret = [];
    for (var i = 0; i < 6; i++) {
        const nx = x + dx[i];
        const ny = y + dy[i];
        
        if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
            // Check if board[x][y] has the same owner and hasn't been visited
            if (board[nx][ny] == owner && findArr(open, [nx, ny]) == -1 && findArr(closed, [nx, ny]) == -1)
                ret.push([nx, ny]);
        }
    }
    return ret;
}

/**
 * Performs a Breadth-First Search (BFS) to check for a winning path.
 * @param {number} owner - The player owner ID (1: Blue, 2: Red).
 * @returns {Array<Array<number>>|false} The winning path as an array of coordinates, or false.
 */
function checkWin(owner) {
    var open = [], openPrev = [], closed = [], closedPrev = [];
    
    // Blue (owner=1) connects Left (x=0) to Right (x=SIZE-1)
    // Red (owner=2) connects Top (y=0) to Bottom (y=SIZE-1)
    const END_DIM = (owner == 1 ? 0 : 1); // Blue aims for x=SIZE-1, Red aims for y=SIZE-1

    for (var a = 0; a < SIZE; a++) {
        const startX = (owner == 1 ? 0 : a);
        const startY = (owner == 1 ? a : 0);

        // Check if the starting cell is owned by the player
        if (board[startX][startY] == owner) {
            open.length = openPrev.length = closed.length = closedPrev.length = 0;
            var pathFound = false;

            open.push([startX, startY]);
            openPrev.push(-1); 

            while (open.length > 0) {
                var u = open.shift();
                var uI = openPrev.shift();

                closed.push(u);
                closedPrev.push(uI);

                // Win condition: Reaching the opposite edge (index SIZE-1)
                if (u[END_DIM] == SIZE - 1) {
                    pathFound = true;
                    break;
                }

                var connections = getConnections(u[0], u[1], owner, open, closed);
                for (var i = 0; i < connections.length; i++) {
                    open.push(connections[i]);
                    openPrev.push(closed.length - 1);
                }
            }

            if (pathFound) {
                var path = [];
                var u = closed.length - 1;
                while (closedPrev[u] != -1) {
                    path.push(closed[u]);
                    u = closedPrev[u];
                }
                path.push([startX, startY]);
                path.reverse();
                active = false;
                return path;
            }
        }
    }
    return false;
}

/**
 * Placement rule: both (cellVal / dieA) and (cellVal / dieB) must be integers
 */
function isAllowedToPlace(x, y){
  if (board[x][y] !== -1) return false;
  if (dieA === null || dieB === null) return false;
  const val = boardValues[x][y];
  if (dieA === 0 || dieB === 0) return false;
  const a = val / dieA;
  const b = val / dieB;
  return isIntClose(a) && isIntClose(b);
}

// --- Canvas Drawing Functions ---

/**
 * Draws a single hexagon on the canvas (fills and strokes).
 */
function drawHexagon(c, x, y, r) {
    c.beginPath();
    c.moveTo(x, y - r);
    for (var i = 0; i < 6; i++)
        c.lineTo(x + r * Math.cos(Math.PI * (1.5 + 1 / 3 * i)), y + r * Math.sin(Math.PI * (1.5 + 1 / 3 * i)));
    c.closePath();
    c.fill();
    c.stroke();
}

/**
 * Draws a single hexagon outline (stroke only).
 */
function drawHexagonOutline(c, x, y, r) {
    c.beginPath();
    c.moveTo(x, y - r);
    for (var i = 0; i < 6; i++)
        c.lineTo(x + r * Math.cos(Math.PI * (1.5 + 1 / 3 * i)), y + r * Math.sin(Math.PI * (1.5 + 1 / 3 * i)));
    c.closePath();
    c.stroke();
}


/**
 * Draws a line path connecting winning hexes.
 */
function drawPath(c, p) {
    c.lineWidth = 14; // Line width scaled up
    c.strokeStyle = "yellow"; 
    c.lineCap = "round";
    c.beginPath();

    for (var i = 0; i < p.length; i++) {
        const [cx, cy] = getCanvasCenter(p[i][0], p[i][1]);
        if (i === 0) {
            c.moveTo(cx, cy);
        } else {
            c.lineTo(cx, cy);
        }
    }
    c.stroke();
    c.lineCap = "butt";
}

/**
 * Determines the selected hex coordinate [x, y] using geometric distance.
 */
function getSel(e) {
    const rect = outputCanvas.getBoundingClientRect();
    // Use the actual canvas dimensions set in JS for scaling reference
    const scaleX = outputCanvas.width / rect.width;
    const scaleY = outputCanvas.height / rect.height;
    
    // Calculate canvas pixel coordinates
    const canvasX = (e.clientX - rect.left) * scaleX;
    const canvasY = (e.clientY - rect.top) * scaleY;

    let closestHex = [-1, -1];
    
    // Iterate through all hexes to find the one closest to the click point
    for (let x = 0; x < SIZE; x++) {
        for (let y = 0; y < SIZE; y++) {
            // Calculate center of this hex
            const [cx, cy] = getCanvasCenter(x, y);

            // Calculate distance squared
            const dx = canvasX - cx;
            const dy = canvasY - cy;
            const distanceSq = dx * dx + dy * dy;

            // If the point is inside the HEX_R radius, select it
            if (distanceSq < HEX_R * HEX_R) { 
                sel = [x, y];
                return;
            }
        }
    }

    sel = [-1, -1];
}

/**
 * The main drawing loop for the game board.
 */
function draw() {
    // We rely on dynamic canvas size set by calculateCanvasSize()
    ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
    
    // 1. Draw Goal Boundaries (Red/Blue outlines around perimeter hexes)
    const BOUNDARY_R = HEX_R + 2;
    ctx.lineWidth = 4; // Width of the boundary line
    ctx.lineJoin = 'round';
    ctx.fillStyle = 'transparent'; 

    // --- Red Borders (Top/Bottom) ---
    ctx.strokeStyle = 'var(--red-dark)'; 
    // Top: Iterate through X (0 to SIZE-1) for Y=0
    for (let x = 0; x < SIZE; x++) {
        const [cx, cy] = getCanvasCenter(x, 0);
        drawHexagonOutline(ctx, cx, cy, BOUNDARY_R);
    }
    // Bottom: Iterate through X (0 to SIZE-1) for Y=SIZE-1
    for (let x = 0; x < SIZE; x++) {
        const [cx, cy] = getCanvasCenter(x, SIZE - 1);
        drawHexagonOutline(ctx, cx, cy, BOUNDARY_R);
    }

    // --- Blue Borders (Left/Right) ---
    ctx.strokeStyle = 'var(--accent-2)'; 
    // Left: Iterate through Y (0 to SIZE-1) for X=0
    for (let y = 0; y < SIZE; y++) {
        const [cx, cy] = getCanvasCenter(0, y);
        drawHexagonOutline(ctx, cx, cy, BOUNDARY_R);
    }
    // Right: Iterate through Y (0 to SIZE-1) for X=SIZE-1
    for (let y = 0; y < SIZE; y++) {
        const [cx, cy] = getCanvasCenter(SIZE - 1, y);
        drawHexagonOutline(ctx, cx, cy, BOUNDARY_R);
    }

    // 2. Draw the Hexagons
    ctx.lineWidth = 1;

    for (var x = 0; x < SIZE; x++) {
        for (var y = 0; y < SIZE; y++) {
            const owner = board[x][y];
            const cellValue = boardValues[x][y];
            
            let isHovered = (x == sel[0] && y == sel[1]);
            let isAllowed = isAllowedToPlace(x, y);

            // 1. Calculate Center Coordinates
            const [cx, cy] = getCanvasCenter(x, y);

            // 2. Determine Fill and Stroke Color
            if (owner !== -1) { 
                // Owned Tiles (Blue or Red)
                ctx.strokeStyle = "white"; 
                ctx.fillStyle = owner === 1 ? "rgb(0,154,172)" : "rgb(255,0,39)";
            } else {
                // Empty Tiles 
                ctx.fillStyle = 'rgb(240, 240, 240)'; 
                
                // Set empty tile stroke to current player's color
                ctx.strokeStyle = current === 1 ? 'var(--accent-2)' : 'var(--red-dark)'; 

                // Stronger highlight for allowed moves
                if (isAllowed) {
                    ctx.fillStyle = isHovered 
                        ? (current === 1 ? 'rgba(31, 120, 200, 1.0)' : 'rgba(227, 74, 74, 1.0)') 
                        : 'rgba(225, 225, 225, 1)';
                    ctx.strokeStyle = isHovered 
                        ? 'white' 
                        : (current === 1 ? 'var(--accent-2)' : 'var(--red-dark)'); 
                }
            }

            // 3. Draw Hexagon
            ctx.lineWidth = 1;
            drawHexagon(ctx, cx, cy, HEX_R);

            // 4. Draw Text (Cell Value)
            ctx.fillStyle = owner !== -1 ? 'white' : 'rgb(51, 65, 85)'; 
            
            // Increased font size for better readability on larger tiles
            const fontSize = '18px'; 
            
            if (isAllowed && owner === -1) {
                // Highlight text for allowed moves
                ctx.fillStyle = isHovered ? 'white' : (current === 1 ? 'var(--accent-2)' : 'var(--red-dark)');
                ctx.font = `700 ${fontSize} Inter, sans-serif`; 
            } else {
                ctx.font = `600 ${fontSize} Inter, sans-serif`; 
            }
            
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(cellValue, cx, cy);

            // 5. Draw Hover Outline (for visual confirmation)
            if (isHovered && owner === -1 && isAllowed) {
                ctx.strokeStyle = current === 1 ? 'var(--accent)' : 'var(--red)';
                ctx.lineWidth = 3;
                drawHexagonOutline(ctx, cx, cy, HEX_R);
            }
        }
    }
}


/** Handles mouse down/click event to place a piece. */
function mouseDown(e) {
    if (e.button !== 0 || !active) return; 

    let event = e.touches ? e.touches[0] : e;
    // Use the geometric selection method
    getSel(event); 

    if (sel[0] !== -1 && sel[1] !== -1) {
        const x = sel[0];
        const y = sel[1];
        
        if (board[x][y] === -1) {
            if (isAllowedToPlace(x, y)) {
                place(x, y, current);
                afterPlacement();
            } else {
                showCustomMessage('Invalid Move', `The value ${boardValues[x][y]} is not a common multiple of ${dieA} and ${dieB}.`);
                tone(120, 0.08);
            }
        }
    }
}

function place(x, y, owner) {
    if (board[x][y] === -1) {
        occupiedCount++;
    }
    board[x][y] = owner;
    moveHistory.push({x, y, owner});
    log(`${owner===1?'Blue':'Red'} placed on (${x+1},${y+1}) value ${boardValues[x][y]}`);
    tone(owner === 1 ? 600 : 400, 0.08);
}

function afterPlacement(){
    draw();

    const pPath = checkWin(current);
    if (pPath){
        drawPath(ctx, pPath);
        announceWin(current);
        return;
    }
    
    if (occupiedCount >= TOTAL_CELLS) {
        announceDraw();
        return;
    }
    
    current = current === 1 ? 2 : 1;
    updateTurnLabel();
    setTimeout(startTurn, 50);
}

function botMove(){
    if (current !== 2 || mode !== 'single') return;
    
    const allowed = [];
    for(let x=0; x<SIZE; x++) {
        for(let y=0; y<SIZE; y++) {
            if (isAllowedToPlace(x, y)) {
                allowed.push({x, y});
            }
        }
    }
    
    if (allowed.length === 0){
        log('Bot has no allowed moves; passes.');
        current = 1; updateTurnLabel(); setTimeout(startTurn, 300);
        return;
    }
    
    let best = allowed[0];
    let bestScore = Infinity;
    
    for (const pos of allowed){
        const distBottom = SIZE - 1 - pos.y;
        const distCenter = Math.abs(pos.x - Math.floor(SIZE/2));
        
        // Simple heuristic: Red prioritizes tiles closer to the bottom edge (distBottom=0)
        // and central in the horizontal direction (distCenter=0).
        const score = distBottom * 3 + distCenter; 
        if (score < bestScore){ bestScore = score; best = pos; }
    }
    
    place(best.x, best.y, 2);
    afterPlacement();
}


function startTurn(){
    if (!active) return; 

    rollDice(()=>{
        const hasAllowed = boardValues.some((col, x) => col.some((val, y) => isAllowedToPlace(x, y)));
        const playerString = current === 1 ? 'Blue' : (mode === 'single' ? 'Red (Bot)' : 'Red');

        if (!hasAllowed){
            log(`${playerString} has no allowed cells for ${dieA} & ${dieB}. Passing turn.`);
            current = current === 1 ? 2 : 1;
            updateTurnLabel();
            setTimeout(startTurn, 300);

        } else if (current === 2 && mode === 'single'){
            log('Red (Bot) is thinking...');
            draw(); 
            setTimeout(botMove, 600 + Math.random()*500);
        } else {
            log(`${playerString} may place a piece on a highlighted tile.`);
            draw(); 
        }
    });
}

function rollDice(cb){
    dieA = null; dieB = null;
    dieAEl.classList.remove('ready'); dieBEl.classList.remove('ready');
    dieAEl.textContent = '...'; dieBEl.textContent = '...';
    let frames = 10;
    const iv = setInterval(()=>{
        dieAEl.textContent = Math.floor(Math.random()*10)+1;
        dieBEl.textContent = Math.floor(Math.random()*10)+1;
        tone(220 + Math.random()*200, 0.04);
        frames--;
        if (frames <= 0){
            clearInterval(iv);
            dieA = Math.floor(Math.random()*10)+1;
            dieB = Math.floor(Math.random()*10)+1;
            dieAEl.textContent = dieA; dieBEl.textContent = dieB;
            dieAEl.classList.add('ready'); dieBEl.classList.add('ready');
            tone(440, 0.08);
            log(`Dice rolled: ${dieA} & ${dieB}`);
            if (cb) cb();
        }
    }, 70);
}

// --- UI and Modal Handlers ---

function showCustomMessage(title, message) {
    document.getElementById('modal-title').textContent = title;
    document.getElementById('modal-message').textContent = message;
    document.getElementById('modal-backdrop').classList.add('active');
}

function announceWin(player){
    draw();
    log(`${player===1?'Blue':'Red'} wins!`);
    active = false;
    tone(player === 1 ? 800 : 700, 0.3);
    setTimeout(()=>{ 
        const title = `${player===1?'Blue':'Red'} Wins!`;
        const msg = player === 1 
            ? 'Congratulations! Blue connected Left (Column 0) to Right (Column 10)!'
            : 'Congratulations! Red connected Top (Row 0) to Bottom (Row 10)!';
        showCustomMessage(title, msg); 
    }, 80);
}

function announceDraw(){
    draw();
    log('Game ends in a Draw.');
    active = false;
    tone(200, 0.5);
    setTimeout(()=>{ showCustomMessage('Draw!', 'The board is full, and neither player completed a connection.'); }, 80);
}

function closeModal() {
    document.getElementById('modal-backdrop').classList.remove('active');
    if (!active) init();
}

function showInstructions() {
    document.getElementById('instructionsModal').classList.add('active');
}

function hideInstructions() {
    document.getElementById('instructionsModal').classList.remove('active');
}

function updateTurnLabel(){ 
    turnLabel.textContent = current===1 ? 'Blue' : (mode==='single' ? 'Red (Bot)' : 'Red'); 
    turnLabel.style.color = current===1 ? 'var(--accent)' : 'var(--red)';
}

function initBoardData() {
    board = new Array(SIZE).fill(0).map(() => new Array(SIZE).fill(-1));
    boardValues = new Array(SIZE).fill(0).map(() => new Array(SIZE).fill(0));
    
    let value = 1;
    for (let y = 0; y < SIZE; y++) {
        for (let x = 0; x < SIZE; x++) {
            boardValues[x][y] = value++;
        }
    }
}

function init(){
    initBoardData();
    moveHistory = [];
    current = 1; 
    dieA = dieB = null;
    sel = [-1, -1];
    occupiedCount = 0;
    active = true;

    // Calculate canvas size dynamically based on the new HEX_R
    calculateCanvasSize(); 

    dieAEl.textContent = '-'; dieBEl.textContent = '-';
    dieAEl.classList.add('ready'); dieBEl.classList.add('ready');
    
    updateTurnLabel();
    draw();
    setTimeout(startTurn, 200);
}

function load() {
    mode = modeSelect.value;
    modeLabel.textContent = `Mode: ${mode==='single'?'Single':'Multi'}`;
    init();
}


// --- Event Listeners ---

outputCanvas.addEventListener('pointerdown', mouseDown);
outputCanvas.addEventListener('pointermove', (e) => {
    if (active) {
        let event = e.touches ? e.touches[0] : e;
        getSel(event);
        draw();
    }
}); 
outputCanvas.addEventListener('pointerleave', () => { sel = [-1, -1]; draw(); });


document.getElementById('passBtn').addEventListener('click', ()=>{
  if (!active || current === 2 && mode === 'single') return; 

  const hasAllowed = boardValues.some((col, x) => col.some((val, y) => isAllowedToPlace(x, y)));
  if (hasAllowed) {
    showCustomMessage('Invalid Action', 'You must play on a common multiple when one is available. You cannot pass yet.');
    return;
  }

  log(`${current===1?'Blue':'Red (human)'} passed.`);
  current = current === 1 ? 2 : 1;
  updateTurnLabel();
  setTimeout(startTurn, 300);
});

document.getElementById('undoBtn').addEventListener('click', ()=>{
    if (!active) return;
    
    let lastMove;
    if (moveHistory.length > 0) {
        lastMove = moveHistory.pop();
        board[lastMove.x][lastMove.y] = -1;
        occupiedCount--;
    }
    
    // If in single player mode, ensure we also undo the bot's move if the last move was the player's
    if (mode === 'single' && lastMove && lastMove.owner === 1 && moveHistory.length > 0) {
        const botMove = moveHistory.pop();
        board[botMove.x][botMove.y] = -1;
        occupiedCount--;
    } else if (mode === 'multi' && lastMove) {
        // In multiplayer, the current player is the one whose turn it is now (which is the one who *just* moved if active was still true).
        // Since afterPlacement flips the current player, we must reset the current player to the owner of the last undone move.
    }
    
    if (lastMove) current = lastMove.owner; // Set turn back to the player whose move was *last* removed
    
    draw();
    log(`Undo move. It is now ${current===1?'Blue':'Red'}'s turn.`);
    updateTurnLabel();
    setTimeout(startTurn, 100);
});

document.getElementById('newBtn').addEventListener('click', ()=> init());
document.getElementById('howToPlayBtn').addEventListener('click', showInstructions);
document.getElementById('instructionsModal').addEventListener('click', (e) => {
    if (e.target.id === 'instructionsModal' || e.target.classList.contains('modal-close-btn')) {
        hideInstructions();
    }
});

modeSelect.addEventListener('change', (e)=>{ 
    mode = e.target.value; 
    modeLabel.textContent = `Mode: ${mode==='single'?'Single':'Multi'}`; 
    init(); 
});


window.addEventListener('load', load); 
</script>
</body>
</html>
